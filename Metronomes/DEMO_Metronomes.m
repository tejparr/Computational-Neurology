function DEMO_Metronomes                        
% This demo is designed to illustrate the way in which we may detect
% stimuli, like those generated by a metronome, with a periodic pattern.
% Specifically, it simulates the performance of a simple task in which a
% we must align our actions to the timings of a periodic stimulus. This is
% an interesting problem in that it is perhaps the simplest case of
% a task in which we periodically change our motor plans, and thus deals
% with the interface between planning of sequential movements and
% continuous implementation of these movements. Furthermore, it goes beyond
% a simple mapping from a discrete time-step to a fixed interval of
% continuous time, as the timing of each step must be adjusted to fit
% regularities in the outside world.
%
% Practically, this demo works through use of an active Bayesian filtering
% scheme formulated in continuous time. It assumes the use of a generative
% model formulated in generalised coordinates of motion. This model
% includes a series of oscillators at different frequences that are used to
% predict the frequency of an external stimulus. This is like using an 
% online Fourier basis set to estimate different frequencies. It also 
% includes beliefs that a body part (or computer cursor) is drawn to one of 
% two locations, with the location changing based upon a discrete 
% transition matrix. This allows for an interpretation of a discrete 
% planning-like operation which emerges from continuous dynamics.
%
% A key sub-problem in formulating this model is how periodic switching may
% occur. This is formulated here by assuming that some parts of the period
% of the oscillator are associated with updating of beliefs about our
% current position, and other parts of the cycle are associated with
% updates of our beliefs about where we will move next. Between the two is
% a period of time in which both are fixed, to insulate one belief from the
% other until the appropriate time.
%
% Thomas Parr
%--------------------------------------------------------------------------

close all
rng default % For reproducibility
SKIP = 0;   % Option to skip to comprehensive exploration of parameter space

% Simulation under default parameters
%==========================================================================
OPT.plot  = 1;                            % Turn on plotting
OPT.ani   = 0;                            % Turn off animation
OPT.T     = 4000;                         % Time-steps
[Y,~,t]   = MetronomeModel(OPT);          % Construct generative model under defaults and invert
y = Y{1};
z = y;

if ~SKIP

% Demonstrate effect of changing stimulus frequency
%--------------------------------------------------------------------------
OPT.freq  = 7;                            % Set faster frequency
MetronomeModel(OPT);                      % Construct generative model and invert

% Demonstrate effect of occlusions
%--------------------------------------------------------------------------
troughs   = find(islocalmin(y(1,:)));
y(1,troughs(round(0.5*length(troughs))):troughs(round(0.85*length(troughs))))...
          = y(1,troughs(round(0.5*length(troughs))));

% OPT.ani   = 1;                            % Turn on animation
MetronomeModel(OPT,[],y);                 % Construct generative model and invert

% Demonstrate effect of no stimuli
%--------------------------------------------------------------------------
OPT.ani   = 0;                            % Turn off animation
MetronomeModel(OPT,[],zeros(size(y)));    % Construct generative model and invert

% Demonstrate effect of lesions
%==========================================================================
figure('Name','Parameter manipulations','Color','w')

OPT.plot  = 0;                            % Turn off plotting

% Effect of precision of target selection
%--------------------------------------------------------------------------
subplot(3,1,1)
imagesc([t(1),t(end)],[-1,1],max(y(1,:))-y(1,:)), hold on, colormap gray, clim([-1 max(y(1,:))]), axis xy
gamma = linspace(log(1),log(2),4);        % Range of parameters to use
for i = 1:4
    clear P
    P.gamma = gamma(i);                   % Reduce precision of policies
    Y = MetronomeModel(OPT,P,y);          % Construct generative model and invert
    plot(t,Y{1}(2,:),'LineWidth',2,'Color',[i/5 1 i/5])
end
axis tight
box off
ax = gca;
ax.XAxisLocation = "origin";
ax.TickLength = [0 0];
xlabel('Time (ms)')
title('Precision of target selection')

% Effect of confidence in persistent occlusion status
%--------------------------------------------------------------------------
subplot(3,1,2)
imagesc([t(1),t(end)],[-1,1]/2,max(y(1,:))-y(1,:)), hold on, colormap gray, clim([-1 max(y(1,:))]), axis xy
zeta = linspace(log(1/4),log(2),4);
for i = 1:4
    clear P
    P.zeta = zeta(i);              % Confident in persistent occluder status
    Y = MetronomeModel(OPT,P,y);   % Construct generative model and invert
    plot(t,Y{1}(2,:),'LineWidth',2,'Color',[1, (5-i)/5 (5-i)/5])
end
axis tight
box off
ax = gca;
ax.XAxisLocation = "origin";
ax.TickLength = [0 0];
xlabel('Time (ms)')
title('Persistence of occluders')

% Effect of precision of temporal chunking
%--------------------------------------------------------------------------
subplot(3,1,3)
imagesc([t(1),t(end)],[-1,1]/2,max(y(1,:))-y(1,:)), hold on, colormap gray, clim([-1 max(y(1,:))]), axis xy
alpha = linspace(log(3),log(1),4);
for i = 1:4
    clear P
    P.alpha = alpha(i);                  % Blurring
    Y = MetronomeModel(OPT,P,y);         % Construct generative model and invert
    plot(t,Y{1}(2,:),'LineWidth',2,'Color',[(5-i)/5 (5-i)/5 1])
end
axis tight
box off
ax = gca;
ax.XAxisLocation = "origin";
ax.TickLength = [0 0];
xlabel('Time (ms)')
title('Precision of chunking')

% Additional possible parameter manipulations
%==========================================================================
% clear P
% 
% P.rho  = log(1);                      % Reduce radius of limit cycle
% MetronomeModel(OPT,P,y);              % Construct generative model and invert
% 
% clear P
% 
% P.xi   = -log(4);                     % Increase attraction to limit cycle
% MetronomeModel(OPT,P,y);              % Construct generative model and invert
%==========================================================================

else

% Illustrate interactions between the three key parameters above
%--------------------------------------------------------------------------
% The simulations above show several different kinds of deficit, affecting
% the different phases of the trial. These include:
%   (1) slow initiation of healthy behaviour 
%   (2) decrement in amplitude throughout the trial 
%   (3) decrement in amplitude specifically in stimulus omission phase
% This suggests that a possible measure to examine the behaviour of these
% is to look at the deviation from the 'optimal' healthy trajectory at the
% initial stimulus presentation, later in the stimulus presentation period
% and during the period of the stimulus omission. In all cases, we would
% expect the accumulated squared difference from a healthy trajectory to
% increase over time. However, the average rate at which this increases
% will vary for the above deficits. Specifically, we would expect a higher
% rate of accumulation at the very start of the stimulus presentation will
% be high for deficit (1), but will be relatively low subsequently. For
% (2), we would expect an increase in all phases. For (3) we would expect a
% disproportionate increase in rate in the final phase with the simulus
% omitted.

% Create stimulus stream with 2/3 stimulus presented and final 1/3 omitted
%--------------------------------------------------------------------------
troughs   = find(islocalmin(z(1,:)));
z(1,troughs(round(2/3*length(troughs))):end)...
          = z(1,troughs(round(0.5*length(troughs))));
OPT.plot  = 0;                       % Turn off plotting
OPT.T     = 3000;                    % Change time-steps to mutiple of 3
P.gamma   = log(4);                  % Very high confidence (i.e., supramaximal performance)
[Y,~,t]   = MetronomeModel(OPT,P,z); % Invert 'healthy' model 
Yh = Y{1}(2,:);                      % Gold standard behaviour
dt = t(2)-t(1);                      % Time interval
T  = [1 round(size(z,2)/3); ...      % From start...
     round(size(z,2)/3)+1   ...      % ...to halfway through stimulus presentation...
     2*round(size(z,2)/3);  ...      % ...and from then to omission of stimulus...
     2*round(size(z,2)/3)+1 ...      % ...until...
     size(z,2)];                     % ...end of trial.

% Parameter values to use
%--------------------------------------------------------------------------
[Alpha,Zeta,Gamma] = meshgrid(linspace(log(1),log(4),8),linspace(log(1/8),log(2),8),linspace(log(1),log(4),8));
% D{1}               = zeros(size(Alpha));
% D{2}               = zeros(size(Alpha));
% D{3}               = zeros(size(Alpha));
% 
% for i = 1:length(D{1}(:))
%     P.alpha = Alpha(i);
%     P.zeta  = Zeta(i);
%     P.gamma = Gamma(i);
%     Y       = MetronomeModel(OPT,P,z);
%     d       = MetronomeDeficit(Yh,Y{1}(2,:),T,dt);
%     for k = 1:3
%         D{k}(i) = d(k);
%     end
%     save('D.mat','D')
% end

load('D.mat');

labels{1} = 'log(alpha)';
labels{2} = 'log(zeta)';
labels{3} = 'log(gamma)';

MetronomePlot3D(D,Alpha,Zeta,Gamma,labels)

end

function D = MetronomeDeficit(y,Y,T,dt)
% This function returns the average rate of increase of accumulated squared
% devations between two behavioural timeseries (y and Y) during intervals
% determined by the matrix T. This takes the minimum with the symmetrical
% behavioural pattern to account for phase reversals.
%--------------------------------------------------------------------------

n  = size(T,1);              % Number of intervals
D  = zeros(1,size(T,1));     % Rate of cummulative squared difference

for i = 1:size(T,1)
    D(i)  = min([sum((y(T(i,1):T(i,2)) - Y(T(i,1):T(i,2))).^2),...
                 sum((y(T(i,1):T(i,2)) + Y(T(i,1):T(i,2))).^2)])/(dt*(T(i,2)-T(i,1)));
end

function MetronomePlot3D(D,X,Y,Z,labels)
% Produces a transparent plot to illustrate scalar volumetric data
%--------------------------------------------------------------------------

figure('Name','Parameter exploration','Color','w')
sx = linspace(min(X(:)),max(X(:)),size(X,1));
sy = linspace(min(Y(:)),max(Y(:)),size(Y,1));
sz = linspace(min(Z(:)),max(Z(:)),size(Z,1));

for i = 1:numel(D)
    subplot(numel(D),1,i)
    h = slice(X,Y,Z,exp(D{i}),sx,sy,sz); alpha('color')
    colormap(zeros(256,3));
    set(h,'EdgeColor','none',...
        'FaceColor','interp',...
        'FaceAlpha','interp');
    axis square, axis tight
    clim([min(exp([D{:}]),[],'all') max((exp([D{:}])),[],'all')])
    xlabel(labels{1}), ylabel(labels{2}), zlabel(labels{3})
    view(45,70)
end

figure('Name','Slices','Color','w')
for i = 1:3, D{i} = smooth3(D{i},'gaussian',5); end
for j = 1:3
    for i = 2:2:8
        subplot(3,4,(j-1)*4+i/2)
        imagesc(sx,sz,exp(-squeeze(D{j}(i,:,:))')), colormap gray, axis square, axis tight, axis xy
    end
end
